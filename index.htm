<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cantonese Speech Snake - Infinite & Fair</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Microsoft JhengHei', 'Arial', sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
            background-color: #f0f0f0;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: #333;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        #score-board {
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 25px;
            border-radius: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #4CAF50;
            width: fit-content;
        }

        #leaderboard {
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            width: 180px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        #leaderboard h3 {
            margin: 0 0 10px 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            font-size: 16px;
        }

        /* Interaction UI */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            z-index: 50;
            display: none;
            min-width: 300px;
        }

        #instruction-modal {
            border: 6px solid #d32f2f;
        }

        #gameover-modal {
            border: 6px solid #333;
            background-color: #fff0f0;
        }

        h1, h2 { margin: 0 0 20px 0; }

        .btn {
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            margin-top: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        #btn-restart { background-color: #FF5722; font-size: 24px; }
        #btn-restart:active { background-color: #E64A19; }

        /* Mobile Button */
        #mobile-confirm-btn {
            display: none;
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 50px;
            background-color: #4CAF50;
            color: white;
            font-size: 22px;
            border: none;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            cursor: pointer;
            z-index: 100;
            font-weight: bold;
            border: 3px solid white;
        }
        
        #mobile-confirm-btn:active {
            background-color: #45a049;
            transform: translateX(-50%) scale(0.95);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">分數: 0</div>
        <div id="leaderboard">
            <h3>Mass Leaderboard</h3>
            <div id="leaderboard-list">Loading...</div>
        </div>
    </div>

    <div id="instruction-modal" class="modal">
        <h2 style="color:#d32f2f">讀出這個字!</h2>
        <span id="current-word-display" style="font-size: 80px; font-weight:bold; display:block; margin:20px 0; color:#333;"></span>
        <div style="font-size: 14px; color: #666;">(Therapist: Press Space/Enter)</div>
    </div>

    <div id="gameover-modal" class="modal">
        <h1 style="color:#D32F2F">Game Over!</h1>
        <p style="font-size: 20px;">被大蛇吃掉了 (Eaten)!</p>
        <p style="font-size: 24px; font-weight:bold;">Final Score: <span id="final-score">0</span></p>
        <button id="btn-restart" class="btn">再來一次 (Try Again)</button>
    </div>
    
    <button id="mobile-confirm-btn">正確 (Correct)</button>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- Configuration ---
    const WORD_LIST = [
        "蛇", "手", "生", "四", "山", "商", "信", "送", "心", "修", 
        "搜", "瘦", "水", "睡", "詩", "使", "斯", "師", "市", "十", 
        "士", "時", "思", "史", "世", "室", "試", "施", "食", "飾", 
        "屎", "示", "絲", "獅", "私", "石", "識", "送", "樹", "書", 
        "數", "說"
    ];

    const COLORS = ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#FFC300', '#9C27B0', '#00BCD4'];
    const BOSS_NAMES = ["King Snake", "Big Boss", "Dragon"];
    const BLOB_NAMES = ["Siu Ming", "Happy", "HK Boy", "Cat", "Guest 99", "Student A", "Lucky"];

    // World Dimensions (Infinite Canvas effect)
    const WORLD_WIDTH = 3000;
    const WORLD_HEIGHT = 3000;
    
    // INCREASED FOOD COUNT
    const TARGET_FOOD_COUNT = 15; 

    // --- Audio ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'success') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(523.25, now); osc.frequency.exponentialRampToValueAtTime(1046.5, now + 0.1); gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5); osc.start(); osc.stop(now + 0.5);
        } else if (type === 'eat_blob') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(100, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 0.1); osc.start(); osc.stop(now + 0.1);
        } else if (type === 'eat_boss') {
            osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.3); gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3); osc.start(); osc.stop(now + 0.3);
        } else if (type === 'gameover') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(100, now + 0.5); gainNode.gain.setValueAtTime(0.3, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5); osc.start(); osc.stop(now + 0.5);
        }
    }

    // --- Game Entities ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const scoreEl = document.getElementById('score-board');
    const lbListEl = document.getElementById('leaderboard-list');
    const instructionModal = document.getElementById('instruction-modal');
    const gameoverModal = document.getElementById('gameover-modal');
    const wordDisplayEl = document.getElementById('current-word-display');
    const mobileBtn = document.getElementById('mobile-confirm-btn');
    const restartBtn = document.getElementById('btn-restart');
    const finalScoreEl = document.getElementById('final-score');

    let width, height; // Screen dimensions
    let score = 0;
    let gameState = 'PLAYING'; 
    let mouse = { x: 0, y: 0 }; // Screen mouse position
    let camera = { x: 0, y: 0 }; // Top-left of visible area in world coords

    // Player
    let player = {
        x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2, // Start in middle of world
        size: 20, speed: 3, angle: 0, tail: [], name: "You", color: '#4CAF50'
    };

    let foodItems = []; 
    let currentTargetFood = null; 

    let blobBots = [];
    let snakeBots = []; 

    // --- Logic ---

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }

    function initGame() {
        resize();
        score = 0;
        gameState = 'PLAYING';
        
        // Reset UI
        gameoverModal.style.display = 'none';
        instructionModal.style.display = 'none';
        mobileBtn.style.display = 'none';
        scoreEl.innerText = "分數: 0";

        // Reset Player to center of WORLD
        player.x = WORLD_WIDTH / 2;
        player.y = WORLD_HEIGHT / 2;
        player.size = 20;
        player.tail = [];
        for(let i=0; i<5; i++) player.tail.push({x: player.x, y: player.y});

        // Reset Enemies
        blobBots = [];
        for(let i=0; i<30; i++) spawnBlobBot(); 

        snakeBots = [];
        spawnSnakeBot(BOSS_NAMES[Math.floor(Math.random() * BOSS_NAMES.length)]);

        // Spawn initial food items (More this time)
        foodItems = [];
        for(let i=0; i<TARGET_FOOD_COUNT; i++) spawnFood();

        updateLeaderboard();
    }

    function spawnFood() {
        const padding = 100;
        foodItems.push({
            x: Math.random() * (WORLD_WIDTH - padding * 2) + padding,
            y: Math.random() * (WORLD_HEIGHT - padding * 2) + padding,
            word: WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)],
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            size: 40,
            pulse: Math.random() * Math.PI
        });
    }

    function spawnBlobBot() {
        blobBots.push({
            x: Math.random() * WORLD_WIDTH,
            y: Math.random() * WORLD_HEIGHT,
            size: Math.random() * 15 + 10,
            color: COLORS[Math.floor(Math.random() * COLORS.length)],
            angle: Math.random() * Math.PI * 2,
            speed: Math.random() * 1.5 + 0.5,
            name: BLOB_NAMES[Math.floor(Math.random() * BLOB_NAMES.length)],
            turnTimer: 0
        });
    }

    function spawnSnakeBot(name) {
        let s = {
            x: Math.random() * WORLD_WIDTH,
            y: Math.random() * WORLD_HEIGHT,
            size: 50 + Math.random() * 20,
            speed: 2.2,
            angle: Math.random() * Math.PI * 2,
            tail: [],
            name: name,
            color: '#D32F2F',
            turnTimer: 0,
            targetAngle: Math.random() * Math.PI * 2
        };
        
        // Ensure boss spawns far away
        if (getDist(player, s) < 800) {
            s.x = (s.x + WORLD_WIDTH/2) % WORLD_WIDTH;
            s.y = (s.y + WORLD_HEIGHT/2) % WORLD_HEIGHT;
        }

        let length = 30;
        for(let i=0; i<length; i++) s.tail.push({x: s.x, y: s.y});
        snakeBots.push(s);
    }

    function update() {
        if (gameState !== 'PLAYING') return;

        // Update Camera position to center on player
        camera.x = player.x - width / 2;
        camera.y = player.y - height / 2;

        // 1. Player Movement 
        const worldMouseX = mouse.x + camera.x;
        const worldMouseY = mouse.y + camera.y;
        const dx = worldMouseX - player.x;
        const dy = worldMouseY - player.y;
        const distToMouse = Math.sqrt(dx*dx + dy*dy);
        
        if (distToMouse > 5) {
            player.angle = Math.atan2(dy, dx);
            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;
        }
        updateTail(player);
        handleWallBounce(player);

        // 2. Blob Bots
        blobBots.forEach((b, i) => {
            b.x += Math.cos(b.angle) * b.speed;
            b.y += Math.sin(b.angle) * b.speed;
            b.turnTimer++;
            if(b.turnTimer > 60) { b.angle += (Math.random() - 0.5); b.turnTimer = 0; }
            handleWallBounce(b);

            if (getDist(player, b) < player.size + b.size) {
                if(player.size > b.size * 1.1) {
                    playSound('eat_blob');
                    score += 5;
                    player.size += 0.5;
                    blobBots.splice(i, 1);
                    spawnBlobBot();
                    updateLeaderboard();
                }
            }
        });

        // 3. Boss Snake Logic
        snakeBots.forEach((s, index) => {
            if (s.size > player.size * 1.1 && getDist(player, s) < 500) {
                 s.targetAngle = Math.atan2(player.y - s.y, player.x - s.x);
            } else {
                 s.turnTimer++;
                 if(s.turnTimer > 150) { s.targetAngle = Math.random() * Math.PI * 2; s.turnTimer = 0; }
            }
            
            let diff = s.targetAngle - s.angle;
            while (diff <= -Math.PI) diff += Math.PI*2;
            while (diff > Math.PI) diff -= Math.PI*2;
            s.angle += diff * 0.015;

            s.x += Math.cos(s.angle) * s.speed;
            s.y += Math.sin(s.angle) * s.speed;

            handleWallBounce(s);
            updateTail(s);

            let dist = getDist(player, s);
            if (dist < player.size + s.size) {
                // EATING LOGIC
                // Must be at least 10% larger to eat someone
                if (player.size > s.size * 1.1) {
                    playSound('eat_boss');
                    score += 150;
                    player.size += 8;
                    snakeBots.splice(index, 1);
                    spawnSnakeBot(BOSS_NAMES[Math.floor(Math.random() * BOSS_NAMES.length)]);
                    updateLeaderboard();
                } else if (s.size > player.size * 1.1) {
                    triggerGameOver();
                }
            }
        });

        // 4. Multiple Word Cards Logic
        // Remove eaten cards
        for (let i = foodItems.length - 1; i >= 0; i--) {
            let f = foodItems[i];
            if (getDist(player, f) < (player.size + f.size)) {
                triggerWordChallenge(f);
            }
            f.pulse += 0.05;
        }
        
        // Ensure we always have target count
        while (foodItems.length < TARGET_FOOD_COUNT) {
            spawnFood();
        }
    }

    function updateTail(entity) {
        let spacing = entity.size * 0.5;
        if(entity.tail.length > 0) {
            dragSegment(entity.tail[0], entity.x, entity.y, spacing);
            for(let i=1; i<entity.tail.length; i++) {
                dragSegment(entity.tail[i], entity.tail[i-1].x, entity.tail[i-1].y, spacing);
            }
        }
    }

    function dragSegment(segment, tx, ty, spacing) {
        const dx = tx - segment.x;
        const dy = ty - segment.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > spacing) {
            const angle = Math.atan2(dy, dx);
            segment.x = tx - Math.cos(angle) * spacing;
            segment.y = ty - Math.sin(angle) * spacing;
        }
    }

    function handleWallBounce(entity) {
        // Use WORLD dimensions now
        if(entity.x < 0 || entity.x > WORLD_WIDTH) entity.angle = Math.PI - entity.angle;
        if(entity.y < 0 || entity.y > WORLD_HEIGHT) entity.angle = -entity.angle;
        entity.x = Math.max(0, Math.min(WORLD_WIDTH, entity.x));
        entity.y = Math.max(0, Math.min(WORLD_HEIGHT, entity.y));
    }

    function getDist(e1, e2) {
        return Math.hypot(e1.x - e2.x, e1.y - e2.y);
    }

    function triggerWordChallenge(foodItem) {
        gameState = 'PAUSED';
        currentTargetFood = foodItem; // Remember which one was eaten
        instructionModal.style.display = 'block';
        wordDisplayEl.textContent = foodItem.word;
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            mobileBtn.style.display = 'block';
        }
    }

    function completeWordChallenge() {
        if (gameState !== 'PAUSED') return;
        playSound('success');
        score += 20;
        
        // Grow Player
        for(let i=0; i<4; i++) {
            player.tail.push({ x: player.tail[player.tail.length-1].x, y: player.tail[player.tail.length-1].y });
        }
        if(player.size < 250) player.size += 4;

        // Remove eaten food immediately
        if (currentTargetFood) {
            const idx = foodItems.indexOf(currentTargetFood);
            if (idx > -1) foodItems.splice(idx, 1);
        }
        
        currentTargetFood = null;
        updateLeaderboard();
        
        // Resume
        gameState = 'PLAYING';
        instructionModal.style.display = 'none';
        mobileBtn.style.display = 'none';
    }

    function triggerGameOver() {
        gameState = 'GAMEOVER';
        playSound('gameover');
        finalScoreEl.innerText = score;
        gameoverModal.style.display = 'block';
    }

    function updateLeaderboard() {
        scoreEl.innerText = "分數: " + score;
        
        // SORT STRICTLY BY SIZE (MASS)
        let entities = [
            {name: "You", mass: Math.floor(player.size)},
            ...snakeBots.map(s => ({name: s.name, mass: Math.floor(s.size)})),
            ...blobBots.map(b => ({name: b.name, mass: Math.floor(b.size)}))
        ];

        entities.sort((a, b) => b.mass - a.mass);
        
        let html = "";
        entities.slice(0, 5).forEach((e, i) => {
            let color = (e.name === "You") ? "#4CAF50" : "#fff";
            html += `<div style="color:${color}; margin-bottom:4px;">${i+1}. ${e.name} (${e.mass})</div>`;
        });
        lbListEl.innerHTML = html;
    }

    // --- Drawing ---
    function draw() {
        // Clear screen
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, width, height);

        // SAVE CONTEXT AND TRANSLATE CAMERA
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw World Boundaries (Optional visual aid)
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 5;
        ctx.strokeRect(0,0,WORLD_WIDTH, WORLD_HEIGHT);

        // Draw Grid over entire world
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        const gridSize = 50;
        const startX = Math.floor(camera.x / gridSize) * gridSize;
        const startY = Math.floor(camera.y / gridSize) * gridSize;
        const endX = startX + width + gridSize;
        const endY = startY + height + gridSize;

        for (let x = startX; x <= endX; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_HEIGHT); ctx.stroke();
        }
        for (let y = startY; y <= endY; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_WIDTH, y); ctx.stroke();
        }

        // --- TRANSPARENT LAYER START ---
        // Apply 70% transparency to snakes and blobs
        ctx.globalAlpha = 0.7; 

        // Draw Blob Bots
        blobBots.forEach(b => {
            ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
            ctx.fillStyle = b.color; ctx.fill();
            ctx.fillStyle = '#555'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
            ctx.fillText(b.name, b.x, b.y - b.size - 5);
        });

        // Draw Boss Snake
        snakeBots.forEach(s => {
            for (let i = s.tail.length - 1; i >= 0; i--) {
                ctx.beginPath(); ctx.arc(s.tail[i].x, s.tail[i].y, s.size * 0.9, 0, Math.PI * 2);
                ctx.fillStyle = s.color; ctx.fill();
            }
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fillStyle = s.color; ctx.fill();
            
            ctx.fillStyle = '#000'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
            let danger = s.size > player.size * 1.1 ? "⚠️ DANGER!" : "";
            if (danger) ctx.fillStyle = "red";
            ctx.fillText(s.name + danger, s.x, s.y - s.size - 10);
        });

        // Draw Player
        for (let i = player.tail.length - 1; i >= 0; i--) {
            ctx.beginPath(); ctx.arc(player.tail[i].x, player.tail[i].y, player.size - 2, 0, Math.PI * 2);
            ctx.fillStyle = '#81C784'; ctx.fill(); ctx.strokeStyle = '#2E7D32'; ctx.stroke();
        }
        ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
        ctx.fillStyle = '#4CAF50'; ctx.fill(); ctx.lineWidth = 3; ctx.strokeStyle = '#1B5E20'; ctx.stroke();
        
        // Eyes (keep them opaque for better look, reset alpha temporarily)
        ctx.globalAlpha = 1.0;
        const eyeOffset = player.size / 2.5; const eyeSize = player.size / 4;
        const ex = Math.cos(player.angle); const ey = Math.sin(player.angle);
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(player.x + ex*eyeOffset - ey*eyeOffset, player.y + ey*eyeOffset + ex*eyeOffset, eyeSize, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(player.x + ex*eyeOffset + ey*eyeOffset, player.y + ey*eyeOffset - ex*eyeOffset, eyeSize, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(player.x + ex*(eyeOffset+2) - ey*eyeOffset, player.y + ey*(eyeOffset+2) + ex*eyeOffset, eyeSize/2, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(player.x + ex*(eyeOffset+2) + ey*eyeOffset, player.y + ey*(eyeOffset+2) - ex*eyeOffset, eyeSize/2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center';
        ctx.fillText("You", player.x, player.y - player.size - 10);
        
        ctx.globalAlpha = 0.7; 
        // --- TRANSPARENT LAYER END ---

        // Reset transparency for food cards (they should be solid)
        ctx.globalAlpha = 1.0;

        // Draw multiple food items
        foodItems.forEach(f => {
            ctx.save();
            ctx.translate(f.x, f.y);
            const pulse = 1 + Math.sin(f.pulse) * 0.05;
            ctx.scale(pulse, pulse);
            ctx.fillStyle = 'white';
            ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.fillRect(-f.size, -f.size, f.size*2, f.size*2);
            ctx.strokeStyle = f.color; ctx.lineWidth = 5;
            ctx.strokeRect(-f.size, -f.size, f.size*2, f.size*2);
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#000'; ctx.font = 'bold 36px "Microsoft JhengHei"';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(f.word, 0, 0);
            ctx.restore();
        });

        // RESTORE CONTEXT (Stop camera translation)
        ctx.restore();
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // --- Inputs ---
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    const handleTouch = (e) => {
        e.preventDefault();
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
        if (audioCtx.state === 'suspended') audioCtx.resume();
    };
    window.addEventListener('touchmove', handleTouch, { passive: false });
    window.addEventListener('touchstart', handleTouch, { passive: false });

    window.addEventListener('keydown', (e) => {
        if (gameState === 'PAUSED' && (e.code === 'Space' || e.code === 'Enter')) {
            completeWordChallenge();
        }
    });

    mobileBtn.addEventListener('click', (e) => { e.stopPropagation(); completeWordChallenge(); });
    restartBtn.addEventListener('click', (e) => { e.stopPropagation(); initGame(); });

    window.addEventListener('resize', resize);
    
    // Start
    initGame();
    gameLoop();

</script>
</body>
</html>